(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{415:function(e,t,a){"use strict";a.r(t);var o=a(10),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[e._v("#")]),e._v(" 应用场景")]),e._v(" "),a("p",[e._v("::: warning1\n大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：")]),e._v(" "),a("ul",[a("li",[e._v("分布式协调")]),e._v(" "),a("li",[e._v("分布式锁")]),e._v(" "),a("li",[e._v("元数据/配置信息管理")]),e._v(" "),a("li",[e._v("HA高可用性\n:::")])]),e._v(" "),a("h2",{attrs:{id:"分布式协调"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式协调"}},[e._v("#")]),e._v(" 分布式协调")]),e._v(" "),a("p",[e._v("这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上"),a("strong",[e._v("对某个节点的值注册个监听器")]),e._v("，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/images/zookeeper-distributed-coordination.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/docs/distributed-system/images/zookeeper-distributed-coordination.png",alt:"zookeeper-distributed-coordination"}}),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[e._v("#")]),e._v(" 分布式锁")]),e._v(" "),a("p",[e._v("举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也"),a("strong",[e._v("尝试去创建")]),e._v("那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/images/zookeeper-distributed-lock-demo.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/docs/distributed-system/images/zookeeper-distributed-lock-demo.png",alt:"zookeeper-distributed-lock-demo"}}),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"元数据-配置信息管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元数据-配置信息管理"}},[e._v("#")]),e._v(" 元数据/配置信息管理")]),e._v(" "),a("p",[e._v("zookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/images/zookeeper-meta-data-manage.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/docs/distributed-system/images/zookeeper-meta-data-manage.png",alt:"zookeeper-meta-data-manage"}}),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"ha高可用性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ha高可用性"}},[e._v("#")]),e._v(" HA高可用性")]),e._v(" "),a("p",[e._v("这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个"),a("strong",[e._v("重要进程一般会做主备")]),e._v("两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/images/zookeeper-active-standby.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/docs/distributed-system/images/zookeeper-active-standby.png",alt:"zookeeper-active-standby"}}),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);